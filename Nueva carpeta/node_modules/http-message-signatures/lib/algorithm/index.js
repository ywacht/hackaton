"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVerifier = exports.createSigner = void 0;
const crypto_1 = require("crypto");
const constants_1 = require("constants");
function createSigner(alg, key) {
    let signer;
    switch (alg) {
        case 'hmac-sha256':
            signer = async (data) => (0, crypto_1.createHmac)('sha256', key).update(data).digest();
            break;
        case 'rsa-pss-sha512':
            signer = async (data) => (0, crypto_1.createSign)('sha512').update(data).sign({
                key,
                padding: constants_1.RSA_PKCS1_PSS_PADDING,
            });
            break;
        case 'rsa-v1_5-sha256':
            signer = async (data) => (0, crypto_1.createSign)('sha256').update(data).sign({
                key,
                padding: constants_1.RSA_PKCS1_PADDING,
            });
            break;
        case 'ecdsa-p256-sha256':
            signer = async (data) => (0, crypto_1.createSign)('sha256').update(data).sign(key);
            break;
        default:
            throw new Error(`Unsupported signing algorithm ${alg}`);
    }
    return Object.assign(signer, { alg });
}
exports.createSigner = createSigner;
function createVerifier(alg, key) {
    let verifier;
    switch (alg) {
        case 'hmac-sha256':
            verifier = async (data, signature) => {
                const expected = (0, crypto_1.createHmac)('sha256', key).update(data).digest();
                const sig = Buffer.from(signature);
                return sig.length === expected.length && (0, crypto_1.timingSafeEqual)(sig, expected);
            };
            break;
        case 'rsa-pss-sha512':
            verifier = async (data, signature) => (0, crypto_1.createVerify)('sha512').update(data).verify({
                key,
                padding: constants_1.RSA_PKCS1_PSS_PADDING,
            }, Buffer.from(signature));
            break;
        case 'rsa-v1_5-sha256':
            verifier = async (data, signature) => (0, crypto_1.createVerify)('sha256').update(data).verify({
                key,
                padding: constants_1.RSA_PKCS1_PADDING,
            }, Buffer.from(signature));
            break;
        case 'ecdsa-p256-sha256':
            verifier = async (data, signature) => (0, crypto_1.createVerify)('sha256').update(data).verify(key, Buffer.from(signature));
            break;
        default:
            throw new Error(`Unsupported signing algorithm ${alg}`);
    }
    return Object.assign(verifier, { alg });
}
exports.createVerifier = createVerifier;
//# sourceMappingURL=index.js.map